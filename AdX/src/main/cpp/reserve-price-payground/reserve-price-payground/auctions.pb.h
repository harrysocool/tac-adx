// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: auctions.proto

#ifndef PROTOBUF_auctions_2eproto__INCLUDED
#define PROTOBUF_auctions_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_auctions_2eproto();
void protobuf_AssignDesc_auctions_2eproto();
void protobuf_ShutdownFile_auctions_2eproto();

class AdxQuery;
class AuctionReport;
class DataBundle;

enum MarketSegment {
  MALE = 0,
  FEMALE = 1,
  YOUNG = 2,
  OLD = 3,
  LOW_INCOME = 4,
  HIGH_INCOME = 5
};
bool MarketSegment_IsValid(int value);
const MarketSegment MarketSegment_MIN = MALE;
const MarketSegment MarketSegment_MAX = HIGH_INCOME;
const int MarketSegment_ARRAYSIZE = MarketSegment_MAX + 1;

const ::google::protobuf::EnumDescriptor* MarketSegment_descriptor();
inline const ::std::string& MarketSegment_Name(MarketSegment value) {
  return ::google::protobuf::internal::NameOfEnum(
    MarketSegment_descriptor(), value);
}
inline bool MarketSegment_Parse(
    const ::std::string& name, MarketSegment* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MarketSegment>(
    MarketSegment_descriptor(), name, value);
}
enum Device {
  MOBILE = 0,
  PC = 1
};
bool Device_IsValid(int value);
const Device Device_MIN = MOBILE;
const Device Device_MAX = PC;
const int Device_ARRAYSIZE = Device_MAX + 1;

const ::google::protobuf::EnumDescriptor* Device_descriptor();
inline const ::std::string& Device_Name(Device value) {
  return ::google::protobuf::internal::NameOfEnum(
    Device_descriptor(), value);
}
inline bool Device_Parse(
    const ::std::string& name, Device* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Device>(
    Device_descriptor(), name, value);
}
enum AdType {
  TEXT = 0,
  VIDEO = 1
};
bool AdType_IsValid(int value);
const AdType AdType_MIN = TEXT;
const AdType AdType_MAX = VIDEO;
const int AdType_ARRAYSIZE = AdType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AdType_descriptor();
inline const ::std::string& AdType_Name(AdType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AdType_descriptor(), value);
}
inline bool AdType_Parse(
    const ::std::string& name, AdType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AdType>(
    AdType_descriptor(), name, value);
}
// ===================================================================

class AdxQuery : public ::google::protobuf::Message {
 public:
  AdxQuery();
  virtual ~AdxQuery();

  AdxQuery(const AdxQuery& from);

  inline AdxQuery& operator=(const AdxQuery& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdxQuery& default_instance();

  void Swap(AdxQuery* other);

  // implements Message ----------------------------------------------

  AdxQuery* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdxQuery& from);
  void MergeFrom(const AdxQuery& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string publisher = 1;
  inline bool has_publisher() const;
  inline void clear_publisher();
  static const int kPublisherFieldNumber = 1;
  inline const ::std::string& publisher() const;
  inline void set_publisher(const ::std::string& value);
  inline void set_publisher(const char* value);
  inline void set_publisher(const char* value, size_t size);
  inline ::std::string* mutable_publisher();
  inline ::std::string* release_publisher();
  inline void set_allocated_publisher(::std::string* publisher);

  // repeated .MarketSegment marketSegments = 2;
  inline int marketsegments_size() const;
  inline void clear_marketsegments();
  static const int kMarketSegmentsFieldNumber = 2;
  inline ::MarketSegment marketsegments(int index) const;
  inline void set_marketsegments(int index, ::MarketSegment value);
  inline void add_marketsegments(::MarketSegment value);
  inline const ::google::protobuf::RepeatedField<int>& marketsegments() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_marketsegments();

  // required .Device device = 3;
  inline bool has_device() const;
  inline void clear_device();
  static const int kDeviceFieldNumber = 3;
  inline ::Device device() const;
  inline void set_device(::Device value);

  // required .AdType adtype = 4;
  inline bool has_adtype() const;
  inline void clear_adtype();
  static const int kAdtypeFieldNumber = 4;
  inline ::AdType adtype() const;
  inline void set_adtype(::AdType value);

  // @@protoc_insertion_point(class_scope:AdxQuery)
 private:
  inline void set_has_publisher();
  inline void clear_has_publisher();
  inline void set_has_device();
  inline void clear_has_device();
  inline void set_has_adtype();
  inline void clear_has_adtype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* publisher_;
  ::google::protobuf::RepeatedField<int> marketsegments_;
  int device_;
  int adtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_auctions_2eproto();
  friend void protobuf_AssignDesc_auctions_2eproto();
  friend void protobuf_ShutdownFile_auctions_2eproto();

  void InitAsDefaultInstance();
  static AdxQuery* default_instance_;
};
// -------------------------------------------------------------------

class AuctionReport : public ::google::protobuf::Message {
 public:
  AuctionReport();
  virtual ~AuctionReport();

  AuctionReport(const AuctionReport& from);

  inline AuctionReport& operator=(const AuctionReport& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AuctionReport& default_instance();

  void Swap(AuctionReport* other);

  // implements Message ----------------------------------------------

  AuctionReport* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuctionReport& from);
  void MergeFrom(const AuctionReport& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double firstBid = 1;
  inline bool has_firstbid() const;
  inline void clear_firstbid();
  static const int kFirstBidFieldNumber = 1;
  inline double firstbid() const;
  inline void set_firstbid(double value);

  // required double secondsBid = 2;
  inline bool has_secondsbid() const;
  inline void clear_secondsbid();
  static const int kSecondsBidFieldNumber = 2;
  inline double secondsbid() const;
  inline void set_secondsbid(double value);

  // required double reservedPrice = 3;
  inline bool has_reservedprice() const;
  inline void clear_reservedprice();
  static const int kReservedPriceFieldNumber = 3;
  inline double reservedprice() const;
  inline void set_reservedprice(double value);

  // required .AdxQuery adxQuery = 4;
  inline bool has_adxquery() const;
  inline void clear_adxquery();
  static const int kAdxQueryFieldNumber = 4;
  inline const ::AdxQuery& adxquery() const;
  inline ::AdxQuery* mutable_adxquery();
  inline ::AdxQuery* release_adxquery();
  inline void set_allocated_adxquery(::AdxQuery* adxquery);

  // @@protoc_insertion_point(class_scope:AuctionReport)
 private:
  inline void set_has_firstbid();
  inline void clear_has_firstbid();
  inline void set_has_secondsbid();
  inline void clear_has_secondsbid();
  inline void set_has_reservedprice();
  inline void clear_has_reservedprice();
  inline void set_has_adxquery();
  inline void clear_has_adxquery();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double firstbid_;
  double secondsbid_;
  double reservedprice_;
  ::AdxQuery* adxquery_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_auctions_2eproto();
  friend void protobuf_AssignDesc_auctions_2eproto();
  friend void protobuf_ShutdownFile_auctions_2eproto();

  void InitAsDefaultInstance();
  static AuctionReport* default_instance_;
};
// -------------------------------------------------------------------

class DataBundle : public ::google::protobuf::Message {
 public:
  DataBundle();
  virtual ~DataBundle();

  DataBundle(const DataBundle& from);

  inline DataBundle& operator=(const DataBundle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataBundle& default_instance();

  void Swap(DataBundle* other);

  // implements Message ----------------------------------------------

  DataBundle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataBundle& from);
  void MergeFrom(const DataBundle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .AuctionReport reports = 1;
  inline int reports_size() const;
  inline void clear_reports();
  static const int kReportsFieldNumber = 1;
  inline const ::AuctionReport& reports(int index) const;
  inline ::AuctionReport* mutable_reports(int index);
  inline ::AuctionReport* add_reports();
  inline const ::google::protobuf::RepeatedPtrField< ::AuctionReport >&
      reports() const;
  inline ::google::protobuf::RepeatedPtrField< ::AuctionReport >*
      mutable_reports();

  // @@protoc_insertion_point(class_scope:DataBundle)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::AuctionReport > reports_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_auctions_2eproto();
  friend void protobuf_AssignDesc_auctions_2eproto();
  friend void protobuf_ShutdownFile_auctions_2eproto();

  void InitAsDefaultInstance();
  static DataBundle* default_instance_;
};
// ===================================================================


// ===================================================================

// AdxQuery

// required string publisher = 1;
inline bool AdxQuery::has_publisher() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdxQuery::set_has_publisher() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdxQuery::clear_has_publisher() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdxQuery::clear_publisher() {
  if (publisher_ != &::google::protobuf::internal::kEmptyString) {
    publisher_->clear();
  }
  clear_has_publisher();
}
inline const ::std::string& AdxQuery::publisher() const {
  return *publisher_;
}
inline void AdxQuery::set_publisher(const ::std::string& value) {
  set_has_publisher();
  if (publisher_ == &::google::protobuf::internal::kEmptyString) {
    publisher_ = new ::std::string;
  }
  publisher_->assign(value);
}
inline void AdxQuery::set_publisher(const char* value) {
  set_has_publisher();
  if (publisher_ == &::google::protobuf::internal::kEmptyString) {
    publisher_ = new ::std::string;
  }
  publisher_->assign(value);
}
inline void AdxQuery::set_publisher(const char* value, size_t size) {
  set_has_publisher();
  if (publisher_ == &::google::protobuf::internal::kEmptyString) {
    publisher_ = new ::std::string;
  }
  publisher_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AdxQuery::mutable_publisher() {
  set_has_publisher();
  if (publisher_ == &::google::protobuf::internal::kEmptyString) {
    publisher_ = new ::std::string;
  }
  return publisher_;
}
inline ::std::string* AdxQuery::release_publisher() {
  clear_has_publisher();
  if (publisher_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = publisher_;
    publisher_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AdxQuery::set_allocated_publisher(::std::string* publisher) {
  if (publisher_ != &::google::protobuf::internal::kEmptyString) {
    delete publisher_;
  }
  if (publisher) {
    set_has_publisher();
    publisher_ = publisher;
  } else {
    clear_has_publisher();
    publisher_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .MarketSegment marketSegments = 2;
inline int AdxQuery::marketsegments_size() const {
  return marketsegments_.size();
}
inline void AdxQuery::clear_marketsegments() {
  marketsegments_.Clear();
}
inline ::MarketSegment AdxQuery::marketsegments(int index) const {
  return static_cast< ::MarketSegment >(marketsegments_.Get(index));
}
inline void AdxQuery::set_marketsegments(int index, ::MarketSegment value) {
  assert(::MarketSegment_IsValid(value));
  marketsegments_.Set(index, value);
}
inline void AdxQuery::add_marketsegments(::MarketSegment value) {
  assert(::MarketSegment_IsValid(value));
  marketsegments_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
AdxQuery::marketsegments() const {
  return marketsegments_;
}
inline ::google::protobuf::RepeatedField<int>*
AdxQuery::mutable_marketsegments() {
  return &marketsegments_;
}

// required .Device device = 3;
inline bool AdxQuery::has_device() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AdxQuery::set_has_device() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AdxQuery::clear_has_device() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AdxQuery::clear_device() {
  device_ = 0;
  clear_has_device();
}
inline ::Device AdxQuery::device() const {
  return static_cast< ::Device >(device_);
}
inline void AdxQuery::set_device(::Device value) {
  assert(::Device_IsValid(value));
  set_has_device();
  device_ = value;
}

// required .AdType adtype = 4;
inline bool AdxQuery::has_adtype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AdxQuery::set_has_adtype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AdxQuery::clear_has_adtype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AdxQuery::clear_adtype() {
  adtype_ = 0;
  clear_has_adtype();
}
inline ::AdType AdxQuery::adtype() const {
  return static_cast< ::AdType >(adtype_);
}
inline void AdxQuery::set_adtype(::AdType value) {
  assert(::AdType_IsValid(value));
  set_has_adtype();
  adtype_ = value;
}

// -------------------------------------------------------------------

// AuctionReport

// required double firstBid = 1;
inline bool AuctionReport::has_firstbid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuctionReport::set_has_firstbid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuctionReport::clear_has_firstbid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuctionReport::clear_firstbid() {
  firstbid_ = 0;
  clear_has_firstbid();
}
inline double AuctionReport::firstbid() const {
  return firstbid_;
}
inline void AuctionReport::set_firstbid(double value) {
  set_has_firstbid();
  firstbid_ = value;
}

// required double secondsBid = 2;
inline bool AuctionReport::has_secondsbid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuctionReport::set_has_secondsbid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuctionReport::clear_has_secondsbid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuctionReport::clear_secondsbid() {
  secondsbid_ = 0;
  clear_has_secondsbid();
}
inline double AuctionReport::secondsbid() const {
  return secondsbid_;
}
inline void AuctionReport::set_secondsbid(double value) {
  set_has_secondsbid();
  secondsbid_ = value;
}

// required double reservedPrice = 3;
inline bool AuctionReport::has_reservedprice() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AuctionReport::set_has_reservedprice() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AuctionReport::clear_has_reservedprice() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AuctionReport::clear_reservedprice() {
  reservedprice_ = 0;
  clear_has_reservedprice();
}
inline double AuctionReport::reservedprice() const {
  return reservedprice_;
}
inline void AuctionReport::set_reservedprice(double value) {
  set_has_reservedprice();
  reservedprice_ = value;
}

// required .AdxQuery adxQuery = 4;
inline bool AuctionReport::has_adxquery() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AuctionReport::set_has_adxquery() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AuctionReport::clear_has_adxquery() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AuctionReport::clear_adxquery() {
  if (adxquery_ != NULL) adxquery_->::AdxQuery::Clear();
  clear_has_adxquery();
}
inline const ::AdxQuery& AuctionReport::adxquery() const {
  return adxquery_ != NULL ? *adxquery_ : *default_instance_->adxquery_;
}
inline ::AdxQuery* AuctionReport::mutable_adxquery() {
  set_has_adxquery();
  if (adxquery_ == NULL) adxquery_ = new ::AdxQuery;
  return adxquery_;
}
inline ::AdxQuery* AuctionReport::release_adxquery() {
  clear_has_adxquery();
  ::AdxQuery* temp = adxquery_;
  adxquery_ = NULL;
  return temp;
}
inline void AuctionReport::set_allocated_adxquery(::AdxQuery* adxquery) {
  delete adxquery_;
  adxquery_ = adxquery;
  if (adxquery) {
    set_has_adxquery();
  } else {
    clear_has_adxquery();
  }
}

// -------------------------------------------------------------------

// DataBundle

// repeated .AuctionReport reports = 1;
inline int DataBundle::reports_size() const {
  return reports_.size();
}
inline void DataBundle::clear_reports() {
  reports_.Clear();
}
inline const ::AuctionReport& DataBundle::reports(int index) const {
  return reports_.Get(index);
}
inline ::AuctionReport* DataBundle::mutable_reports(int index) {
  return reports_.Mutable(index);
}
inline ::AuctionReport* DataBundle::add_reports() {
  return reports_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AuctionReport >&
DataBundle::reports() const {
  return reports_;
}
inline ::google::protobuf::RepeatedPtrField< ::AuctionReport >*
DataBundle::mutable_reports() {
  return &reports_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MarketSegment>() {
  return ::MarketSegment_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Device>() {
  return ::Device_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AdType>() {
  return ::AdType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_auctions_2eproto__INCLUDED
